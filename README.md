# react-course
## lesson 1 [ сomponents, JSX, state, props ]

`npm install` -- Устанавливаем все необходимые для работы пакеты из package.json (зависимости) <br/>
`npm run dev` -- Запускаем проект (запускается скрипт прописаный внутри `package.json` с ключем "dev")

---

<!-- 
**React.js** - это библиотека которая была создана компанией facebook для того чтобы ускорить работу их проектов и вдобавок к этому упростить поддерживаемость кода.

Из известных вам сайтов на React написаны такие как slack, instagram, facebook, pinterest.

### Virtual DOM
Ребята из facebook знают о том что DOM c которым вы работаете очень медленный, так как ресурсоемкий и изначально был предназначен просто для отображения элементов.
По этому они и написали виртуальный аналог DOM на JavaScript, с которым делать различные манипуляции стали быстрее. Принцип работы `Virtual DOM` описан в картинке ниже:<br/>
![Виртуальный DOM](https://image.slidesharecdn.com/reactreduxintroduction-151124165017-lva1-app6891/95/react-redux-introduction-9-638.jpg?cb=1448383914)
<br/>
Виртуальный DOM это то к чему обращается реакт тогда когда мы создаем элемент средствами Реакта. 

Виртуальный DOM отличается от реального тем что он быстрый. Он оптимизирован таким образом что при изменении одного элемента - он изменит только этот элемент на странице, а не перезагрузит весь реальный DOM как это было раньше. И сделает это только тогда когда что-то изменилось. -->

### Что такое React?

ReactJS — это JаvaScript библиотека для построения пользовательских интерфейсов. Это не MVC фреймворк. К ней можно применить только V из этой аббревиатуры. Такая узкая сфера применения дает свободу использования React в различных системах в комбинации с другими библиотеками.

React был представлен Facebook в 2013 году, и очень быстро обрел популярность. Сегодня его используют многие известные компании включая Instagram, Airbnb, Ebay, Netflix, Yahoo и [другие](https://github.com/facebook/react/wiki/Sites-Using-React).

Основным отличием React от других JavaScript фреймворков является то, как он управляет состоянием приложения. Если вспомнить, как пользователи взаимодействовали с веб-страницами еще 10–15 лет назад, то увидим такую картину:

![Как было 10-15 лет назад](https://raw.githubusercontent.com/krambertech/react-essential-course/master/01-introduction-to-react/images/001.png)

Сервер всегда возвращал статическую страницу, и реакцией на действия пользователя была полная перезагрузка страницы. Преимуществами такого подхода, была простота в реализации и понимании, недостатками — скорость работы, отзывчивость, UX и потеря состояния при каждой перезагрузке.

Все очень изменилось с появлением AJAX, — это подход к построению интерактивных веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером. То есть, в фоновом режиме отправляются запросы на сервер, приходят с него ответы, изменяется состояние приложения и, соответственно, внешний вид. Именно такой подход породил понятие Single Page Application.

![AJAX](https://raw.githubusercontent.com/krambertech/react-essential-course/master/01-introduction-to-react/images/002.png)

Но каждое визуальное изменение на странице соответствует изменению ее DOM дерева. Не секрет, что все манипуляции с DOM деревом являются очень ресурсоемкими операциями, т.к. изначально DOM дерево было статическим и никакой динамики не предусматривало.

![Изменения на странице](https://raw.githubusercontent.com/krambertech/react-essential-course/master/01-introduction-to-react/images/006.png)

Именно поэтому в React используется виртуальный DOM. Это такая легковесная копия реального DOM дерева на Javascript. Таким образом, React манипулирует не с реальным (синоним — медленным) DOM деревом, а с виртуальным.

![DOM DIFF](https://raw.githubusercontent.com/krambertech/react-essential-course/master/01-introduction-to-react/images/003.png)

Он сравнивает предыдущее состояние виртуального DOM дерева с его следующим состоянием и находит минимальное количество манипуляций, которые можно произвести уже с реальным DOM, чтобы обновить вид приложения согласно его новому состоянию.

![Обновление реального DOM](https://raw.githubusercontent.com/krambertech/react-essential-course/master/01-introduction-to-react/images/004.png)

И это действительно быстро работает. А все что вам нужно делать — это просто менять состояние вашего приложения, а все остальное React сделает уже за вас!


**_Запомните:_** обращаться к элементам страницы по средствам реального DOM в React нельзя, так как это противоречит идеологии виртуального DOM и его использования.

### JSX
Для рендеринга данных в React используется JSX. JSX нужен для JavaScript XML — разметки в стиле XML внутри компонентов React. React работает и без JSX, но именно JSX поможет сделать ваши компоненты более читаемыми, поэтому рекомендуется использовать его.

Поскольку react использует виртуальный dom все елементы которые вы хотите увидеть, необходимо создать. Раньше вы делали это с помощью `document.createElement();` подобная функция есть и в react, её принцип работы такой же, но отличие в том что функция из react создаёт елемент в виртуальном dom, а так же может создавать и экземпляры классов с учетом их свосвойств и функционала. 

Выглядит это приблизительно так:
```javascript
React.createElement('h1', null, 'hello world');
```
На выходе, в браузере появиться такой элемент:  `<h1>hello world<h1>`

Предположим нам необходимо сделать обширное приложение с использованием react, поскольку это атоматически обуслваливает большое количество элементов, а значит и вложеностей, то если делать это без `jsx` получиться трудно-читаемая каша, которую соответственно трудно поддерживать.

with JSX:
```jsx
var jsx = (
	<Container>
		<Nav>
			<NavItem href="home">Home</NavItem>
			<NavItem href="posts">Posts</NavItem>
			<NavItem href="about">About</NavItem>
		</Nav>
	</Container>
)
```

without JSX:
```javascript
var jsx = React.createElement(
	Container,
	null,
	React.createElement(
		Nav,
		null,
		React.createElement(
			NavItem,
			{ href: "home" },
			"Home"
		),
		React.createElement(
			NavItem,
			{ href: "posts" },
			"Posts"
		),
		React.createElement(
			NavItem,
			{ href: "about" },
			"About"
		)
	)
);
```

Это можно еще назвать синтаксическим сахаром для функции createElement. Используя `jsx`, нам не нужно городить сложно читаемые createElement'ы, можно писать привычный "html" прямо в js, который в дальнейшем транспилируется в уже понятный браузеру createElement.

Но нет, это не html внутри js, это jsx, который выглядит как html, у которого есть определённые отличия от html, например: атрибут `for` который предназначен для тега `label`, в jsx пишется как `htmlFor`, поскольку в js слово for является зарезервированым, привычный в html атрибут `class` тоже пишется иначе - `className`. поскольку в js слово class используется для обозначения класса, и ряд других исключений с которыми вы вероятно столкнетесь в дальнейшем.

Есть у него еще одна обязательная особенность, все теги обязательно нужно закрывать, как одинарные так и парные.

Пример: 
```jsx
<input type="text" />
<textarea></textarea>
```

JSX позволяет вам описывать структуру компонентов с помощью понятного синтаксиса, а затем все написанное вами преобразуется в цепочку javascript функций.

В JSX можно использовать переменные, условные конструкции и вызывать функции. Для этого нужно использовать фугурные скобки.

```javascript
var name = 'John Doe';
var app = <h1> My name is {name}! </h1>;
```

```jsx
function getMyName() {
    return 'John Doe';
}

var app = <h1>
    My name is {getMyName()}!
</h1>;
```

```jsx
var age = 20;

var app = <h1>
    Hi! { age > 18 ? 'Your age is more than 18!' : 'Your age is less than 18!' }
</h1>;
```

**_Запомните:_** мы можем использовать все теги которые есть в *html*, но если мы пишем тег с большой буквы это будет являтся *компонентом*. 


### Компоненты
Библиотека React использует компонентный подход, это означает что все индивидуальные элементы вашего приложения, являются компонентами.

Компоненты это своего рода строительные единицы, которые разумеется можно переиспользовать. Под компонентами я подразумеваю классы, которые содержат в себе как визуальную часть индивидуального по смыслу элемента (например разметка статьи), так и логическую, например: функция отображения и скрытия полной информации о статье на странице, будет реализована как метод этого класса.

Визуальная часть компонента в react реализована с помощью такой вещи как [`jsx`](#jsx).

Есть два типа компонентов, и их по разному называют, я называю так - сложные и простые,

**Сложный компонент (class)** - это класс, который наследуется от класса `Component` находящегося в библиотеке `React`, благодаря чему этот класс обретает определенные возможности, в частности такие как состояние и жизненный цикл.
У него есть обязательный метод который называется `render()` который обязательно должен возвращать наше представление (view)
```jsx
import React from 'react';
class Nav extends React.Component {
    render() { // обязательный метод render() который должен возвращать наше view
        return ( 
            <nav class={this.props.type}>
                <ul class={this.props.listType}>
                    {this.props.children}  
                </ul>
            </nav>
        )
    }
}
```

**Простой компонент (functional or stateless)** - это функция, которая ни от чего не наследуется, которая принимает на вход свойства, которые привыкли именовать как `props` (объект) и просто возвращает jsx используя эти `props`, ну или не использует, это зависит от задачи.
```jsx
import React from 'react';

const NavItem = (props) => (
    <li class={props.type}>
        <Link to={`/${props.href}`}>{props.children}</Link>
    </li>
);
```

Есть **обязательное условие**, названия компонентов всегда должны начинатся с большой буквы.

Обычный тег инпута: 
```jsx
<input type="text"/>
```

Компонент с названием Input: 
```jsx
<Input type="text" />
```

Отлично, мы описали компонент, но для того чтобы этот компонент где-то отобразился - этого не достаточно. Для того чтобы наш компонент появился у нас на странице, нам необходимо его вывести, это делается так:
```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import ComponentExample from 'path/to/ComponentExample';

ReactDOM.render(<ComponentExample/>, document.getElementById('app'));
```

**ReactDOM** - Модуль в котором собраны методы для работы с DOM, необходим тогда когда мы работаем с браузером. Такое разделение было сделано для того чтобы уменьшить вес основной библиотеки. Поскольку работа с DOM при создании например десктопного или мобильного приложения просто не нужна.

**ReactDOM.render()** - должен вызываться только один раз, это инициализация, при которой реакт вставляет на страницу в выбранный нами элемент все наше приложение.
Принимает два параметра: 
1. Компонент который должен будет вставлен на страницу. (Принято делать один основной корневой компонент в котором будет находиться все наше приложение)
2. Элемент в который будет вставлен этот компонент.  

PS: **app** - Это просто название (id) элемента на странице .html в котрую мы вставляем наш компонент, называть мы его можем как нам вздумается. 


Посмотреть на то как выглядят компоненты можно и нужно в ветке `components-examples`. <br/>
Для того чтобы в нее попасть, нужно выполнить команду: 
```bash
git checkout components-examples
```

**Напоминаю:** для того чтобы запустить приложение нам необходимо написать в консоли команду `npm install`. 
Если консоль уведомляет нас о том что какой-то модуль не был найден - нужно его установить. Я уже внес все необходимые пакеты в зависимости проекта, по этому команды `npm install` должно хватить. Но в случае если это вдруг не так, или просто на будущее, дополнительные пакеты ставятся по такому принципу - `npm install [package-name] [--save | --save-dev]`, где `package-name` - имя необходимого нам пакета, а флаг `--save` or `--save-dev` записывает название и текущую версию в определенные объект в файле package.json - это нужно для того чтобы в будущем не устанавливать все модули в ручную, а просто написать `npm install` и все установиться.

### State & Props 
У компонентов реакт есть такие понятия как состояние и свойства.

Свойства есть у всех видов компонентов, а состояния только у "сложных". 

**Свойства (props)** - это параметры которые мы можем передавать в компонент, выглядит это так будто мы пишем атрибуты тегу, но на деле, это передается в компонент которому мы это пишем в объект props.
Так можно делать как со сложными компонентами так и с простыми.
```jsx
<Post data={ {title: 'react.'} } />
/*    ^^^^ - надстройка над компонентом
      внутри компонента Post в props.data 
      будет находиться то что мы туда передаем. */
```

В объекте props по умолчанию есть свойство children которое содержит в себе элементы которые находятся внутри компонента. Это свойство особенно тем что: 
1. Мы можем вкладывать компоненты в компоненты и иметь возможность взаимодействовать и модифицировать вложенные компоненты или же просто элементы jsx.
2. В это свойство можно передать как jsx так и обычный текст.
3. Мы можем обойтись без вложености и написать это свойство как обычный параметр компонента, и это тоже будет работать.

```jsx
import React from 'react';
// Например, у нас есть компонент `Posts` и я хочу чтобы внутри него отображались посты, но с 
// учетом определенной структуры которую я прописал внутри компонента Posts. 
class Posts extends React.Component {
    render() {
        <main className="articles">
            <h2>This is my simple blog!</h2>

            {
                this.props.children 
                /* в это место будет вставлено все, что будет 
                   являтся дочерним по отношению к этому компоненту */
            }

            <footer>
                <p>Some content in footer!</p>
            </footer>
        </main>
    }
}

class Layout extends React.Component {
    render() {
        return (
            <div className="wrapper">
                <div className="container">
                    <Posts>
                        <div className="posts-container">
                            {this.props.posts.map((item, index) => {
                                return <Post data={item} key={index} /> 
                                // функция перебирает массив данных и под каждый создает
                                // компонент Post который попадает в props.children 
                                // компонента Posts так как он является дочерним для него  
                            })}
                        </div>
                    </Posts>
                    <Button 
                        type="subscribe"
                        children="Хочешь подписатся на уникальнейший контен? Тогда не тяни время!"/>
                        {/*
                            написав своство children в виде параметра компонента это также попадает в 
                            своство children и работает корректно.
                        */}
                </div>    
            </div>
        );
    }
}
```

У нас есть возможность не только передавать свойства как атрибут, но и указывать свои свойства по умолчанию, для этого у компонента есть свойство `defaultProps`, а так-же мы можем валидировать свойства которые мы передаем в компонент с помощью специальной тулзы которая называется `propTypes`, начиная если я не ошибаюсь, с 15й версии, эту фичу вырезали из ядра реакта, и вынесли в отдельный модуль `prop-types` который без проблем ставится с помощью `npm`.

[*defaultProps*](https://reactjs.org/docs/react-without-es6.html#declaring-default-props) - свойство класса в котором мы можем указать свойства(props) класса по умолчанию. Это должно быть статическим свойством. 
```jsx
Button.defaultProps = {
    type: 'default'
}
// Button - название нашего компонента, которому мы хотим задать свойства по умолчанию.
// Свойство defaultProps обязательно должно быть статическим.
```

[*propTypes*](https://reactjs.org/docs/typechecking-with-proptypes.html) - это специальный модуль, который позволяет нам валидировать свойства, приходящие в наш компонент, на соответствие по типу данных, а так-же делать их обязательными для работы компонента.
```jsx
Button.propTypes = {
    type: PropTypes.string,
    children: PropTypes.string.isRequired
}
// Button - название нашего компонента, у которого мы хотим проверять props на соответствие по типу данных.
// Свойство propTypes обязательно должно быть статическим. 
``` 

**Состояние (state)** - это объект, предназначеный для того чтобы хранить в нем орпеделенные свойства которые могут меняеться, например свойство я хочу при нажатии на кнопку отображить или скрывать что-то в моем компоненте, для этого я могу создать свойство visible в объекте `state` со значением `true` или `false` и при нажатии менять это значение на противоположное, а в jsx проверять значение этого свойства и в зависимости от этого отображать или скрывать определенный элемент, например. 

Изменить свойство объекта state можно только с помощью функции `setState()` которая появляется в нашем компоненте после того как мы расширим его от класса `Component`.

Функция `setState()` на вход принимает объект в котором необходимо указать свойство которое вы хотите изменить, и функцию callback которая сработает после изменения state. Первый аргумент также можно написать функцией, в таком случае, в первый аргумент этой функции попадет this.state (да, до того как он изменится, конечно)

```javascript
changeStateExample() {
    this.setState({visible: !this.state.visible});
    // or:
    // this.setState( prev => ({visible: !prev.visible}) )
}
```
В примере выше я написал функцию которая при отработке изменит `state.visible` на противоположное значение.

**Но**, есть одно но. Функция `setState` изменяет `state` не сразу, а в определенный момент, перед повторной отрисовкой компонента. Под повторной отрисовкой компонента я подразумеваю повторный вызов метода `render()` у компонента в котором был изменен `state`, если в этом компоненте были использованы другие компоненты они тоже перересуются.  Если бы этого не происходило, то при изменении `state` мы бы не смогли как-то контролировать визуальную составляющую компонента.
Детальнее об особенностях работы этой функции можно прочесть [здесь](https://reactjs.org/docs/state-and-lifecycle.html), а так-же узнать больше о callback'е [здесь](https://medium.learnreact.com/setstate-takes-a-callback-1f71ad5d2296)

**Задания (Делать в ветке playground):**
1. Создать компонент `Menu` и вывести его на страницу. (разделять на файлы)
2. Использовать `state` для того чтобы скрыть или отобразить элементы меню, скрывать и показывать меню по нажатию на кнопку.
3. Создать основной компонент в котором будет находится все наше приложение, и подключить к нему наше меню. 
4. Передавать в компонент меню свойство, которое будет массивом в котором лежат элементы меню, отрисовать элементы меню отталкиваясь от передаваемых в компонент "меню" данных.

**Задания (Делать в ветке lesson-1):**
1. Вывести все посты которые лежат в state компонента MainLayout используя специально созданный для этого компонент. (2 балла)
2. Добавить в массив, с объектами постов, свойство "description" в котором будет описание каждого объекта (пример: `{title: "react", description: "React это ... "}`) (2 балла)
3. Ограничить количество символов отображаемых в описании к посту до 120, по нажатию на кнопку "show more" отобразить весь текст и добавить стили которые позволят отличать развернутый компонент от свернутого. (4 балла)
4. Создать компонент с помощью которого можно будет добавлять новый пост
5. Добавить возможность удалять посты
